pp_def('bin_sdev',
       Pars => join( ';',
                     'signal(n)',
                     'int [o] bin(n)',
                     'int [o] nbins()',
                     'double [o] sum(n)',
                     'int [o] nelem(n)',
                     'double [o] sdev(n)',
		     'int [o] ifirst(n)',
		     'int [o] ilast(n)',
		     'double [t] sum2(n)',
		      ),
       OtherPars => join(';', 'double min_sn', 'long min_nelem' ),
       Code => q{
                int curind = 0;         /* index of current bin */
                double sum2 = 0;        /* sum of signal**2 in current bin */
                double sum = 0;         /* sum of signal in current bin */
                int nin = 0;            /* number of elements in the 
					   current bin */
                double sdev2;           /* square of instantaneous
					   standard deviation */
                loop(n) %{
                    double sumsq;
		    double signal = $signal();
		    double signal2 = signal * signal;
                    sum  += signal;
                    sum2 += signal2;
                    nin++;
                    $bin() = curind;

		    /* rearranged to avoid possible sum * sum overflow */
                    sdev2 = sum2 / nin - ( sum / nin ) * ( sum / nin );

		    if ( nin == 1 )
		      $ifirst( n => curind ) = n;


                    if (   nin >= $COMP(min_nelem) 
		        && sum / sqrt(sdev2) >= $COMP(min_sn)  )
                    {
                        $sum( n => curind ) = sum;
                        $sdev( n => curind ) = sqrt(sdev2);
			$nelem( n => curind ) = nin;
      			$ilast( n => curind ) = n;
			$sum2( n => curind) = sum2;
                        sum2 = sum = nin = 0;
                        curind++;
                    }
                   %}
		    /* record last bin if it's not empty */
                    if ( nin )
                    {
#if 0
		      int ii;
		      for ( ii = 0 ; ii < curind ; ii++ )
			   fprintf ( stderr, "%d: %d %g %g %g\n",
			   ii, $nelem( n => ii ),
			   $sum( n => ii ),
			   $sdev( n => ii ),
			   $sum( n => ii ) / $sdev( n => ii ) );
#endif

		        /* a non empty bin means that its S/N is too low.
			   fold it into the previous bin if possible.
			   sometimes that will actually lower the S/N
			   of the previous bin; keep going until we
			   can't fold anymore or we get the proper S/N
			    */
			while ( curind > 0  )
			{
			   int ni;
			   curind -=1;

			   for (ni = $SIZE(n) - nin ; ni < $SIZE(n) ; ni++ )
			     $bin( n => ni ) = curind;

			   sum2 += $sum2( n => curind );
			   sum  += $sum( n => curind );
			   nin  += $nelem( n => curind );
			   sdev2 = sum2 / nin - ( sum / nin ) * ( sum / nin );

			   if ( sum / sqrt(sdev2) >= $COMP(min_sn) )
			     break;
			}	

			$sum( n => curind ) = sum;
			$sdev( n => curind ) = sqrt(sdev2);
			$nelem( n => curind ) = nin;
			$ilast( n => curind ) = $SIZE(n)-1;

#if 0
			ii = curind;
			fprintf( stderr, "final: \n" );
			   fprintf ( stderr, "%d: %d %g %g %g\n",
			   ii, $nelem( n => ii ),
			   $sum( n => ii ),
			   $sdev( n => ii ),
			   $sum( n => ii ) / $sdev( n => ii ) );
#endif

                    }
                /* adjust for possibility of last bin being empty */
                $nbins() = curind + ( nin != 0 );
                   },
       PMCode => q{
        ## no critic ProhibitAccessOfPrivateData
        sub PDL::bin_sdev {
            my ( $vec, $min_sn, $min_nelem ) = @_;

            $min_nelem ||= 2;
            barf( "minimum number of elements must be at least 2\n" )
              if $min_nelem < 2;

            PDL::_bin_sdev_int( $vec, (my $bin = null()),
        			       (my $nbins = null()),
        			       (my $sum = null()),
        			       (my $nelem = null()),
        			       (my $sdev = null()),
        			       (my $ifirst = null()),
        			       (my $ilast = null()),
				       (null()),
        			        $min_sn, $min_nelem
        			    );
            $nbins--;

	    return ( bin => $bin,
	              map { $_->[0], $_->[1]->slice("0:$nbins")->copy} 
			         [ sum    => $sum],
				 [ nelem  => $nelem],
				 [ sdev   => $sdev],
				 [ ifirst => $ifirst],
				 [ ilast  => $ilast],
		   );
        }
      },
      Doc => undef
   );

pp_addpm( { At => 'Top'}, q{

=head2 bin_sdev

=for usage

  %hash = $pdl->bin_sdev( $min_sn);
  %hash = bin_sdev( $pdl, $min_sn, $min_nelem );

=for ref

Adaptively bin a data set using the standard deviation.

B<bin_sdev> groups data into bins whose widths are chosen to achieve
a minimum signal to noise.  The data are typically dependent values
(e.g. flux as a function of energy or counts as a function of radius).
The data should be sorted by the independent variable (e.g. energy or
radius).

Binning begins at the start of the data vector.  Bins are
grown until the minimum signal to noise ratio (specified by
B<$min_sn>) is met, where the signal is the sum of the data and the
noise is the standard deviation of the data in the bin.  If the final
bin has insufficient signal to noise, it is folded into the previous
bin.  In order to avoid singularities in the signal to noise, bins
must have a minimum of two elements; the exact number may be specified
by the optional B<$min_nelem> parameter.

B<bin_sdev> returns a hash with the following entries:

=over

=item C<bin>

The bin indices for the elements in the input data piddle.

=item C<sum>

The sum of the data values in each bin.

=item C<nelem>

The number of data elements in each bin.

=item C<sdev>

The standard deviation of the data in each bin.

=item C<ifirst>

The index into the input data piddle of the first data value in a bin.

=item C<ilast>

The index into the input data piddle of the last data value in a bin.

=back

=cut

});

1;
