#!perl

pp_def('bin_err',
       Pars => join( ';',
                     'signal(n)',
		     'err(n)',
                     'int [o] bin(n)',
                     'int [o] nbins()',
                     'double [o] sum(n)',
                     'int [o] nelem(n)',
                     'double [o] sigma(n)',
		     'int [o] ifirst(n)',
		     'int [o] ilast(n)',
		     'double [t] sum2(n)',
		      ),
       OtherPars => join(';',
                         'double min_sn',
                         'long nmin',
                         'long nmax',
                         'int err_sq' ),
       Code => q{
                int curind = 0;         /* index of current bin */
                double sum = 0;         /* sum of signal in current bin */
                int nin = 0;            /* number of elements in the 
					   current bin */
                double sum_err2 = 0;    /* sum of error^2 in current bin */

                loop(n) %{
                    double err2 = $err();

		    if ( ! $COMP(err_sq) )
		      err2 *= err2;

		    sum_err2 += err2;

                    sum  += $signal();
                    nin++;
                    $bin() = curind;

		    if ( nin == 1 )
		      $ifirst( n => curind ) = n;

                    if (        nin == $COMP(nmax)
                         || (   nin >= $COMP(nmin)
		             && sum / sqrt(sum_err2) >= $COMP(min_sn)  )
                       )
                    {
                        $sum( n => curind ) = sum;
                        $sigma( n => curind ) = sqrt(sum_err2);
			$nelem( n => curind ) = nin;
      			$ilast( n => curind ) = n;
                        sum = sum_err2 = nin = 0;
                        curind++;
                    }
                   %}
		    /* record last bin if it's not empty */
                    if ( nin )
                    {

		        /* a non empty bin means that its S/N is too low.
			   fold it into the previous bin if possible.
			   sometimes that will actually lower the S/N
			   of the previous bin; keep going until we
			   can't fold anymore or we get the proper S/N
			    */
			while ( curind > 0  )
			{
			   double tmp;
			   int ni;
			   curind -=1;

			   for (ni = $SIZE(n) - nin ; ni < $SIZE(n) ; ni++ )
			     $bin( n => ni ) = curind;

			   tmp = $sigma( n => curind );
			   sum_err2 += tmp * tmp;
			   sum  += $sum( n => curind );
			   nin  += $nelem( n => curind );

			   if ( sum / sqrt(sum_err2) >= $COMP(min_sn) )
			     break;
			}	

			$sum( n => curind ) = sum;
			$sigma( n => curind ) = sqrt(sum_err2);
			$nelem( n => curind ) = nin;
			$ilast( n => curind ) = $SIZE(n)-1;

                    }
                /* adjust for possibility of last bin being empty */
                $nbins() = curind + ( nin != 0 );
                   },
       PMCode => q{
        ## no critic ProhibitAccessOfPrivateData
        sub PDL::bin_err {
	    my $opts = 'HASH' eq ref $_[-1] ? pop : {};

	    my ( $vec, $err, $min_sn ) = @_;

	    my %opt = iparse( { err_sq => 0, nmin => 1, nmax => 0},
                               $opts );

            barf( "minimum number of elements must be at least 1\n" )
              if $opt{nmin} < 1;

            PDL::_bin_err_int( $vec, $err,
                                (my $bin   = null()),
                                (my $nbins = null()),
                                (my $sum   = null()),
                                (my $nelem = null()),
                                (my $sigma = null()),
                                (my $ifirst = null()),
                                (my $ilast = null()),
                                (null()),
                                $min_sn, $opt{nmin}, $opt{nmax}, $opt{err_sq}
                              );
            $nbins--;

	    return ( bin => $bin,
	              map { $_->[0], $_->[1]->slice("0:$nbins")->copy} 
			         [ sum    => $sum],
				 [ nelem  => $nelem],
				 [ sigma  => $sigma],
				 [ ifirst => $ifirst],
				 [ ilast  => $ilast],
		   );
        }
      },
      Doc => undef
   );

pp_addpm( { At => 'Top'}, q{

=head2 bin_err

=for usage

  %hash = bin_err( $data, $err, $min_sn, [ \%options ]  );

=for ref

Adaptively bin a data set using errors.

B<bin_err> groups data into bins whose widths are chosen to achieve a
minimum signal to noise ratio (S/N).  The data are typically dependent
values (e.g. flux as a function of energy or counts as a function of
radius).  The data should be sorted by the independent variable
(e.g. energy or radius).

Binning begins at the start of the data vector.  Bins are grown until
the minimum S/N (specified by B<$min_sn>) is met, where the signal is
the sum of the data and the noise is the RSS error in the bin.  If the
final bin has insufficient S/N, it is folded into the previous bin.
The minimum and maximum number of elements in a bin may be specified
via the option hash.

B<bin_err> returns a hash with the following entries:

=over

=item C<bin>

The bin indices for the elements in the input data piddle.

=item C<sum>

The sum of the data values in each bin.

=item C<nelem>

The number of data elements in each bin.

=item C<sigma>

The RSS of the errors in each bin.

=item C<ifirst>

The index into the input data piddle of the first data value in a bin.

=item C<ilast>

The index into the input data piddle of the last data value in a bin.

=back


=head3 Options

Options are parsed by PDL::Options, so unique abbreviations are accepted.

=over

=item nmin (default: 1 )

The minimum number of elements per bin

=item nmax (default: 0 )

The maximum number of elements per bin; set to zero for no limit.

=back


=cut

});

1;
